import numpy as npimport matplotlib . pyplot as pltimport scipy . signal as sigsteps = 1e-2 # Define step sizet = np. arange (0, 2 + steps , steps ) # user defined functiondef step (t):     y = np. zeros (t. shape )     for i in range ( len (t)):         if t[i] >= 0:              y[i] = 1        else:            y[i] = 0    return y #Part 1#Task 1def yt(t):    y = (0.5 - 0.5 * np.exp(-4*t) + np.exp(-6*t)) * step (t)     return y#Task 2numH = [1, 6 , 12]denH = [1, 10 , 24]tout, yout = sig. step (( numH , denH), T = t)plt. figure ( figsize = (10 , 7))plt. subplot (2, 1, 1)plt. plot (t, yt(t))plt. grid ()plt. ylabel ('Hand Calculated')plt. title (' Step Responce y(t)')plt. subplot (2, 1, 2)plt. plot (tout, yout)plt. grid ()plt. ylabel ('Built-in')plt. xlabel ('t')#Task 3numY = [1, 6 , 12]denY = [1, 10 , 24, 0]R, P, K = sig.residue(numY , denY)print("R= ", R)print("P= ", P)print("K= ", K)#Part 2#Task 1numY2 = 25250denY2 = [1, 18, 218, 2036, 9085, 25250, 0]R2, P2, K2 = sig.residue(numY2 , denY2)print("R2= ", R2)print("P2= ", P2)print("K2= ", K2)#Task 2t = np. arange (0, 4.5 + steps , steps ) L = len(R2) y2 = np. zeros(t. shape)for i in range (L):    MAG_R = np.abs(R2[i])    Ang_R = np.angle(R2[i])    Real_P = P2[i].real    Img_P = P2[i].imag    y2 += MAG_R * np.exp(Real_P*t) * np.cos(Img_P*t + Ang_R) *step(t)#Task 3numH2 = 25250denH2 = [1, 18, 218, 2036, 9085, 25250]tout2, yout2 = sig. step (( numH2 , denH2), T = t)plt. figure ( figsize = (10 , 7))plt. subplot (2, 1, 1)plt. plot (t, y2)plt. grid ()plt. ylabel ('Hand Calculated')plt. title (' Step Responce y(t)')plt. subplot (2, 1, 2)plt. plot (tout2, yout2)plt. grid ()plt. ylabel ('Built-in')plt. xlabel ('t')plt. show () 